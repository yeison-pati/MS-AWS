name: Deploy Microservices

on:
  push:
    branches: [ "master" ]

jobs:
  terraform:
    runs-on: ubuntu-latest
    outputs:
      tf_outputs: ${{ steps.tf-outputs.outputs.tf_outputs }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        id: init
        run: terraform -chdir=terraform init

      - name: Terraform Plan
        id: plan
        run: terraform -chdir=terraform plan -no-color

      - name: Terraform Apply
        id: apply
        run: terraform -chdir=terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: tf-outputs
        run: |
          echo 'tf_outputs<<EOF' >> $GITHUB_OUTPUT
          terraform -chdir=terraform output -json >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

  build-and-push-images:
    needs: terraform
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [ "config-server", "discovery-service", "gateway", "order-service", "user-service" ]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        env:
          TF_OUTPUTS: ${{ needs.terraform.outputs.tf_outputs }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          REPO_URL=$(echo "$TF_OUTPUTS" | jq -r ".ecr_repository_urls.value[\"${{ matrix.service }}\"]")
          echo "Building and pushing image for ${{ matrix.service }} -> $REPO_URL:$IMAGE_TAG"
          docker build -t $REPO_URL:$IMAGE_TAG ./${{ matrix.service }}
          docker push $REPO_URL:$IMAGE_TAG

  deploy-to-eks:
    needs: [terraform, build-and-push-images]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to EKS
        env:
          TF_OUTPUTS: ${{ needs.terraform.outputs.tf_outputs }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e
          # Obtener el nombre del cluster desde los outputs de Terraform
          CLUSTER_NAME=$(echo "$TF_OUTPUTS" | jq -r ".eks_cluster_name.value")
          [[ "$CLUSTER_NAME" != "null" && -n "$CLUSTER_NAME" ]] || { echo "Error: Failed to get cluster name"; exit 1; }
          
          # Configurar kubeconfig
          aws eks update-kubeconfig --name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }}
          
          # Desplegar cada servicio
          for service in config-server discovery-service gateway order-service user-service; do
            REPO_URL=$(echo "$TF_OUTPUTS" | jq -r ".ecr_repository_urls.value[\"$service\"]")
            [[ "$REPO_URL" != "null" && -n "$REPO_URL" ]] || { echo "Error: Failed to get repo URL for $service"; exit 1; }
            IMAGE_URL_WITH_TAG="$REPO_URL:$IMAGE_TAG"
            
            echo "Deploying $service with image $IMAGE_URL_WITH_TAG"
            
            # Reemplazar placeholder de imagen en deployment.yml
            sed -i "s|__IMAGE_URL__|$IMAGE_URL_WITH_TAG|g" $service/deployment.yml
            
            # Si es config-server, crear el secret con las credenciales
            if [[ "$service" == "config-server" ]]; then
              # Extraer variables de los outputs de Terraform
              POSTGRES_ENDPOINT=$(echo "$TF_OUTPUTS" | jq -r ".postgres_rds_endpoint.value")
              POSTGRES_PORT=$(echo "$TF_OUTPUTS" | jq -r ".postgres_rds_port.value")
              POSTGRES_USERNAME=$(echo "$TF_OUTPUTS" | jq -r ".postgres_rds_username.value")
              POSTGRES_PASSWORD=$(echo "$TF_OUTPUTS" | jq -r ".postgres_rds_password.value")
              POSTGRES_DB=$(echo "$TF_OUTPUTS" | jq -r ".postgres_rds_db_name.value")
              
              MYSQL_ENDPOINT=$(echo "$TF_OUTPUTS" | jq -r ".mysql_rds_endpoint.value")
              MYSQL_PORT=$(echo "$TF_OUTPUTS" | jq -r ".mysql_rds_port.value")
              MYSQL_USERNAME=$(echo "$TF_OUTPUTS" | jq -r ".mysql_rds_username.value")
              MYSQL_PASSWORD=$(echo "$TF_OUTPUTS" | jq -r ".mysql_rds_password.value")
              MYSQL_DB=$(echo "$TF_OUTPUTS" | jq -r ".mysql_rds_db_name.value")
              
              # Validar valores extraídos
              [[ "$POSTGRES_ENDPOINT" != "null" && -n "$POSTGRES_ENDPOINT" ]] || { echo "Error: Failed to get Postgres endpoint"; exit 1; }
              [[ "$MYSQL_ENDPOINT" != "null" && -n "$MYSQL_ENDPOINT" ]] || { echo "Error: Failed to get MySQL endpoint"; exit 1; }
              
              # Crear secret de Kubernetes con todas las credenciales
              kubectl create secret generic config-server-secret \
                --from-literal=GIT_USERNAME="${{ secrets.GIT_USERNAME }}" \
                --from-literal=GIT_PASSWORD="${{ secrets.GIT_PASSWORD }}" \
                --from-literal=postgres_rds_endpoint="$POSTGRES_ENDPOINT" \
                --from-literal=postgres_rds_port="$POSTGRES_PORT" \
                --from-literal=postgres_rds_username="$POSTGRES_USERNAME" \
                --from-literal=postgres_rds_password="$POSTGRES_PASSWORD" \
                --from-literal=postgres_rds_db_name="$POSTGRES_DB" \
                --from-literal=mysql_rds_endpoint="$MYSQL_ENDPOINT" \
                --from-literal=mysql_rds_port="$MYSQL_PORT" \
                --from-literal=mysql_rds_username="$MYSQL_USERNAME" \
                --from-literal=mysql_rds_password="$MYSQL_PASSWORD" \
                --from-literal=mysql_rds_db_name="$MYSQL_DB" \
                --dry-run=client -o yaml | kubectl apply -f -
            fi
            
            # Aplicar configuración de Kubernetes
            kubectl apply -f $service/ || { echo "Error: Failed to deploy $service"; exit 1; }
          done
  
  cleanup:
    needs: [terraform, build-and-push-images, deploy-to-eks]
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
      
      - name: Terraform init
        run: terraform -chdir=terraform init
      
      - name: Destroy infra
        run: terraform -chdir=terraform destroy -auto-approve