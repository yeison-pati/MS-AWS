name: Deploy Microservices

on:
  push:
    branches: [ "master" ]

jobs:
  terraform:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Terraform Init
        id: init
        run: terraform -chdir=terraform init

      - name: Terraform Plan
        id: plan
        run: terraform -chdir=terraform plan -no-color

      - name: Terraform Apply
        id: apply
        run: terraform -chdir=terraform apply -auto-approve

      - name: Get Terraform Outputs
        run: |
          terraform -chdir=terraform output -json > tf_outputs.json
          # Verificar que el archivo se generÃ³ correctamente
          if [[ ! -s tf_outputs.json ]]; then
            echo "Error: tf_outputs.json is empty or doesn't exist"
            exit 1
          fi
          echo "Terraform outputs saved successfully"

      - name: Upload tf_outputs.json
        uses: actions/upload-artifact@v4
        with:
          name: tf_outputs
          path: tf_outputs.json
          retention-days: 1


  build-and-push-images:
    needs: terraform
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [ "config-server", "discovery-service", "gateway", "order-service", "user-service" ]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Download tf_outputs.json
        uses: actions/download-artifact@v4
        with:
          name: tf_outputs
          path: .

      - name: Load outputs and validate
        run: |
          if [[ ! -f tf_outputs.json ]] || [[ ! -s tf_outputs.json ]]; then
            echo "Error: tf_outputs.json not found or empty"
            exit 1
          fi

          REPO_URL=$(jq -r ".ecr_repository_urls.value[\"${{ matrix.service }}\"]" tf_outputs.json)
          if [[ "$REPO_URL" == "null" || -z "$REPO_URL" ]]; then
            echo "Error: Cannot extract ECR repository URL for ${{ matrix.service }}"
            echo "Available services in outputs:"
            jq -r ".ecr_repository_urls.value | keys[]" tf_outputs.json || echo "Failed to parse ECR repositories"
            exit 1
          fi

          echo "Repository URL for ${{ matrix.service }}: $REPO_URL"

      - name: Build, tag, and push image to Amazon ECR
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          REPO_URL=$(jq -r ".ecr_repository_urls.value[\"${{ matrix.service }}\"]" tf_outputs.json)
          echo "Building and pushing image for ${{ matrix.service }} -> $REPO_URL:$IMAGE_TAG"

          if [[ -z "$REPO_URL" || "$REPO_URL" == "null" ]]; then
            echo "Error: Invalid repository URL"
            exit 1
          fi

          docker build -t $REPO_URL:$IMAGE_TAG ./${{ matrix.service }}
          docker push $REPO_URL:$IMAGE_TAG


  deploy-to-eks:
    needs: [terraform, build-and-push-images]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download tf_outputs.json
        uses: actions/download-artifact@v4
        with:
          name: tf_outputs
          path: .

      - name: Load outputs and validate
        run: |
          if [[ ! -f tf_outputs.json ]] || [[ ! -s tf_outputs.json ]]; then
            echo "Error: tf_outputs.json not found or empty"
            exit 1
          fi

          CLUSTER_NAME=$(jq -r ".eks_cluster_name.value" tf_outputs.json)
          if [[ "$CLUSTER_NAME" == "null" || -z "$CLUSTER_NAME" ]]; then
            echo "Error: Cannot extract EKS cluster name"
            exit 1
          fi
          echo "EKS Cluster: $CLUSTER_NAME"

      - name: Deploy to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e
          CLUSTER_NAME=$(jq -r ".eks_cluster_name.value" tf_outputs.json)
          aws eks update-kubeconfig --name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }}

          for service in config-server discovery-service gateway order-service user-service; do
            REPO_URL=$(jq -r ".ecr_repository_urls.value[\"$service\"]" tf_outputs.json)
            [[ "$REPO_URL" != "null" && -n "$REPO_URL" ]] || { echo "Error: Failed to get repo URL for $service"; exit 1; }
            IMAGE_URL_WITH_TAG="$REPO_URL:$IMAGE_TAG"

            echo "Deploying $service with image $IMAGE_URL_WITH_TAG"

            cp $service/deployment.yml $service/deployment-temp.yml
            sed -i "s|__IMAGE_URL__|$IMAGE_URL_WITH_TAG|g" $service/deployment-temp.yml

            if [[ "$service" == "config-server" ]]; then
              POSTGRES_ENDPOINT=$(jq -r ".postgres_rds_endpoint.value" tf_outputs.json)
              POSTGRES_PORT=$(jq -r ".postgres_rds_port.value" tf_outputs.json)
              POSTGRES_USERNAME=$(jq -r ".postgres_rds_username.value" tf_outputs.json)
              POSTGRES_PASSWORD=$(jq -r ".postgres_rds_password.value" tf_outputs.json)
              POSTGRES_DB=$(jq -r ".postgres_rds_db_name.value" tf_outputs.json)

              MYSQL_ENDPOINT=$(jq -r ".mysql_rds_endpoint.value" tf_outputs.json)
              MYSQL_PORT=$(jq -r ".mysql_rds_port.value" tf_outputs.json)
              MYSQL_USERNAME=$(jq -r ".mysql_rds_username.value" tf_outputs.json)
              MYSQL_PASSWORD=$(jq -r ".mysql_rds_password.value" tf_outputs.json)
              MYSQL_DB=$(jq -r ".mysql_rds_db_name.value" tf_outputs.json)

              kubectl create secret generic config-server-secret \
                --from-literal=GIT_USERNAME="${{ secrets.GIT_USERNAME }}" \
                --from-literal=GIT_PASSWORD="${{ secrets.GIT_PASSWORD }}" \
                --from-literal=postgres_rds_endpoint="$POSTGRES_ENDPOINT" \
                --from-literal=postgres_rds_port="$POSTGRES_PORT" \
                --from-literal=postgres_rds_username="$POSTGRES_USERNAME" \
                --from-literal=postgres_rds_password="$POSTGRES_PASSWORD" \
                --from-literal=postgres_rds_db_name="$POSTGRES_DB" \
                --from-literal=mysql_rds_endpoint="$MYSQL_ENDPOINT" \
                --from-literal=mysql_rds_port="$MYSQL_PORT" \
                --from-literal=mysql_rds_username="$MYSQL_USERNAME" \
                --from-literal=mysql_rds_password="$MYSQL_PASSWORD" \
                --from-literal=mysql_rds_db_name="$MYSQL_DB" \
                --dry-run=client -o yaml | kubectl apply -f -
            fi

            kubectl apply -f $service/deployment-temp.yml
            for file in $service/*.yml; do
              if [[ "$file" != "$service/deployment.yml" && "$file" != "$service/deployment-temp.yml" ]]; then
                kubectl apply -f "$file" || echo "Warning: Failed to apply $file"
              fi
            done
            rm -f $service/deployment-temp.yml
          done
  
  cleanup:
    needs: [terraform, build-and-push-images, deploy-to-eks]
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.AWS_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false
      
      - name: Terraform init
        run: terraform -chdir=terraform init
      
      - name: Destroy infra
        run: terraform -chdir=terraform destroy -auto-approve